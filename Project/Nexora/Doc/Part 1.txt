👉 1. Start with definitions
--- Authentication is the process of verifying the identity of a user (ex: username & password, OTP, JWT token).
--- Authorization is the process of checking what resources or actions the authenticated user is allowed to access (ex: admin can add users, normal user cannot).

👉 2. Give real-world example
--- Authentication → Logging into Gmail with email & password.
--- Authorization → After login, only you can see your mails, not others’.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
--- Django → the web framework (core).
--- DRF → builds APIs on top of Django.
--- simplejwt → Its a package adds secure JWT authentication for those APIs.
--- PyMySQL → connects Django to a MySQL database.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
JWT:

--- JWT stands for JSON Web Token.
--- It’s a compact, self-contained token used for authentication between client and server.
--- It has three parts — header, payload, and signature.
--- After login, the server issues a JWT, and the client sends it with each request.
(👉 "User login ஆன பிறகு, server ஒரு JWT token குடுக்கும். அதுக்குப் பிறகு, client ஒவ்வொரு request அனுப்பும் போதும் அந்த JWT token-ஐ சேர்த்து server-க்கு அனுப்பும்.")
--- Since it is stateless, the server doesn’t need to store sessions, which makes it scalable and fast.

✅ (If they want more)
--- The header defines algorithm, payload has user info and expiry, and the signature ensures the token is not tampered.

✅ What is the meaning of compact in coding?
--- In coding, compact means writing code or data in a shorter, claener and memory-efficent way.

✅ What is the meaning of self-contained token in coding?
--- A self-contained token is a token(like a JWT) that holds all the required user information inside itself,
--- so the server doesn't need to look it up in a database.

✅ What is the meaning of stateless in coding?
--- Statelessn in coding means the server does not remember any information about the client between request.
--- each request is independent.

✅ What is the meaning of session in coding?
--- A session is a way to store user data on the server(like login info) so it can be used accross multiple requests.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
👉 Structure:
xxxxx.yyyyy.zzzzz → Header.Payload.Signature

--- Header → algorithm & token type (ex: HS256).
--- Payload → user info + claims (ex: user id, role, expiry time).
--- Signature → ensures token is not tampered (generated using secret key).

🔹 Important

--- Header and Payload in JWT are Base64-encoded JSON.
--- Signature is also Base64-encoded, but it’s generated using hashing + secret key.
--- Anyone can decode Header & Payload, but only the server (with secret key) can verify Signature.

👉 In short:

--- Header + Payload = message
--- Signature = seal 🔒 with server’s secret key
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
🔹 Q: “What is Base64 and why does JWT use it?”

--- Base64 is an encoding scheme that converts data into a text format using only A–Z, a–z, 0–9, +, /.
--- It’s not encryption, just a safe way to represent data in text.
--- JWT uses Base64 to encode the header and payload so they can be safely sent in HTTP headers.

✅ (If they dig deeper)
--- Anyone can decode Base64, but the signature ensures the JWT cannot be tampered with.

⚡ Quick analogy:
--- Base64 = Writing something in English → but instead of letters, you map it into a fixed alphabet system → machine-readable.
--- Not secret, just transport-friendly.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. CREATE DATABASE nexora CHARACTER SET utf8mb4;

--- What it does: Creates a new database named nexora.
--- CHARACTER SET utf8mb4:
--- Tells MySQL to use the utf8mb4 encoding, which is the modern and recommended choice.
--- It supports all Unicode characters, including emojis (😀🔥💯), unlike utf8 which is limited.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

2. CREATE USER 'nexora_user'@'%' IDENTIFIED BY 'StrongPassword123!';

--- What it does: Creates a new database user called nexora_user.
--- '%': The % means this user can connect from any host (not just localhost).
--- If you only want local access, you’d use 'nexora_user'@'localhost'.
--- IDENTIFIED BY 'StrongPassword123!': Sets the user’s password to StrongPassword123!.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

3. GRANT ALL PRIVILEGES ON nexora.* TO 'nexora_user'@'%';

--- What it does: Gives the user all permissions (create tables, insert, update, delete, etc.) on the nexora database.
--- nexora.*: Means "all tables inside the nexora database".
--- To 'nexora_user'@'%': Grants those rights specifically to the user you just created.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

4. FLUSH PRIVILEGES;

--- What it does: Refreshes MySQL’s memory of users and privileges.
--- Without this, MySQL might not immediately recognize the new user/permissions until restart.
--- Think of it as "apply the changes now".
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In Database connect in Django (settings.py):

--- 'OPTIONS': { 'init_command': "SET sql_mode='STRICT_TRANS_TABLES'", }
--- OPTIONS → Django oda DB connection-ku extra config.
--- init_command → Connection aana udane oru SQL command run panna.
--- STRICT_TRANS_TABLES → Safe mode ahh enable pannidum → invalid data DB la sneak in aagave koodadhu.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

JWT tokens:

--- Access token valid for 60 minutes.
--- Refresh token valid for 7 days.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1) class User(AbstractUser):

--- AbstractUser = Django oda built-in User (username, email, password irukkum).
--- Neenga extend pannitu extra fields add pannuringa (role, phone, address).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

2) class Roles(models.TextChoices):

--- Idhu oru enum (options list).
--- ADMIN = 'ADMIN', 'Admin' →
--- 'ADMIN' DB la save aagum.
--- 'Admin' UI la kaattum.
--- So, role oda possible values = ADMIN, SELLER, CUSTOMER.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
3) role = models.CharField(...)

--- Role nu oru field create pannuringa.
--- choices=Roles.choices → dropdown maari 3 option mattum select panna mudiyum.
--- default=Roles.CUSTOMER → pudhusaa user create pannumbodhu role = Customer automatically set aagum.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@admin.register(User)
class UserAdmin(DjangoUserAdmin):

--- @admin.register(User) = admin.site.register(User, UserAdmin) shortcut.
--- UserAdmin inherits DjangoUserAdmin, so default user admin behaviour keep pannittu namma changes add pannalam.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Imports & setup:

from django.contrib.auth import get_user_model
from django.contrib.auth.password_validation import validate_password
from rest_framework import serializers

User = get_user_model()

--- get_user_model() → neenga define pannirukkura custom User model-a fetch pannum (hard-coded import avoid agum).
--- validate_password → Django built-in password strength checks (length, common password, etc.).
--- DRF serializers → JSON <-> Python conversion + validation.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

RegisterSerializer:

class RegisterSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True, required=True)
    role = serializers.ChoiceField(choices=User.Roles.choices, default=User.Roles.CUSTOMER)

--- ModelSerializer → auto fields + model-based save.
--- password → write_only=True → response la varadhu (safety).
--- required=True → must send during register.
--- role → ChoiceField → ADMIN/SELLER/CUSTOMER mattum allow.
--- default=CUSTOMER → user specify pannalana default-aa Customer.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

📌 Error summary:

RuntimeError: 'cryptography' package is required for sha256_password or caching_sha2_password auth methods
Cause:

--- Your MySQL server user (nexora_user) is using the default authentication plugin caching_sha2_password.
--- But your Python MySQL driver (PyMySQL) cannot handle it without the cryptography package.

✅ Solution (two options)
Option 1: Install cryptography

--- In your venv, run:

pip install cryptography

--- Then try again:

python manage.py makemigrations
python manage.py migrate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~